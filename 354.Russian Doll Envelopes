widths and heights given as a pair of integers (w, h).
One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope.
//Given envelopes = [[5,4],[6,4],[6,7],[2,3]], the maximum number of envelopes you can Russian doll is 3 ([2,3] => [5,4] => [6,7]).
//æ€è·¯
1.Sort the array. Ascend on width and descend on height if width are same. 

2.Find the longest increasing subsequence based on height.ğŸ”¥300. Longesr Increasing Subsequences(å›ºå®šç›¸å¯¹ä½ç½®ï¼Œè¿™é‡Œå·²ç»æ’åºå¥½äº†ï¼Œé€‚ç”¨)

Since the width is increasing, we only need to consider height.
[3, 4] cannot contains [3, 3], so we need to put [3, 4] before [3, 3] when sorting 
otherwise it will be counted as an increasing number if the order is [3, 3], [3, 4] ğŸ”¥è¿™æ ·å°±ä¼šæœ‰é‡å¤å®½åº¦çš„ä¿¡å°
å…·ä½“ä»£ç å¦‚ä¸‹ï¼š
class Solution { //å¦‚æœåªæœ‰wæˆ–è€…h ç›´æ¥ä¸Šgreedyï¼Œä½†æ˜¯ä½ è€ƒè™‘äº†w h ä¸ä¸€å®šæ»¡è¶³ å‚è€ƒ300 LISï¼ˆä¿æŒåŸæœ‰é¡ºåºï¼‰
public:
    int maxEnvelopes(vector<pair<int, int>>& envelopes) {
        sort(envelopes.begin(),envelopes.end(),cmp);
        vector<int> res;//   reså­˜æ”¾height
        for(auto env:envelopes){ //æ¯æ¬¡è¿­ä»£ç­‰äºåœ¨æ›´æ–°res
            auto it= lower_bound(res.begin(),res.end(),env.second); 
            if(it==res.end()) res.push_back(env.second);
            else 
                *it=env.second;
        }
        return res.size();
    }
    static bool cmp(pair<int, int> pair1,pair<int, int> pair2){
        if(pair1.first==pair2.first) return pair1.second>pair2.second;
        else return pair1.first<pair2.first;
    }
};
